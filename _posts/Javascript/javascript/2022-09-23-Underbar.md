---
title:  "배열, 객체 라이브러리 구현"
excerpt: "Underscore, lodash와 같은 라이브러리 구현"

categories:
  - Javascript
tags:
  - [Javascript, html,codestates]

comment: true

author: Beomhyuck

toc: true
toc_sticky: true
 
date: 2022-09-23
last_modified_at: 2022-09-23
---

Javascript에서 배열 메소드가 지원되지 않을때 자주 사용되던 underscore,lodash와 같은 라이브러리를 직접 구현해보면서 Callback함수의 원리에 대해서 좀더 공부하고자 합니다.

1.slice
===
slice는 배열의 start 인덱스부터 end 인덱스 이전까지의 요소를 shallow copy하여 새로운 배열을 리턴합니다.

```javascript
_.slice = function (arr, start, end) {
  let _start = start || 0 // `start`가 undefined인 경우, slice는 0부터 동작합니다.
  let _end = end;

  // 입력받은 인덱스가 음수일 경우, 마지막 인덱스부터 매칭한다. (예. -1 => arr.length - 1, -2 => arr.length - 2)
  // 입력받은 인덱스는 0 이상이어야 한다.
  if (start < 0) _start = Math.max(0, arr.length + start);
  if (end < 0) _end = Math.max(0, arr.length + end);

  // `end`가 생략될 경우(undefined), slice는 마지막 인덱스까지 동작합니다.
  // `end`가 배열의 범위를 벗어날 경우, slice는 마지막 인덱스까지 동작합니다.
  if (_end === undefined || _end > arr.length) _end = arr.length;

  let result = [];
  // `start`가 배열의 범위를 벗어날 경우, 빈 배열을 리턴합니다.
  for (let i = _start; i < _end; i++) {
    result.push(arr[i]);
  }

  return result;
};
```

<br>

2.take
===

take는 배열의 처음 n개의 element를 담은 새로운 배열을 리턴합니다.
처음부터 n개의 element만 가져야 되므로 0번째 index부터 n-1번째까지 복사하면 됩니다.

```javascript
_.take = function (arr, n) {
  let result = [] ;

  // n이 undefined이거나 음수인 경우, 빈 배열을 리턴합니다.
  if(typeof(n) === "undefined" || n < 0) return result;

  // n이 배열의 길이를 벗어날 경우, 전체 배열을 shallow copy한 새로운 배열을 리턴합니다.
  if(arr.length < n) return arr;

  for(let i = 0;i <n ;i++){
    result = [...result,arr[i]];
  }
  
  return result;
};
```

<br>

3.drop
===

drop는 take와는 반대로, 처음 n개의 element를 제외한 새로운 배열을 리턴합니다.   
n개의 element를 제외하기 때문에 n번째 index부터 배열의 끝까지 복사하면 됩니다.

```javascript


_.drop = function (arr, n) {
  let result = [] ;

  // n이 undefined이거나 음수인 경우, 전체 배열을 shallow copy한 새로운 배열을 리턴합니다.
  if(typeof(n) === "undefined" || n < 0) return arr;

  // n이 배열의 길이를 벗어날 경우, 빈 배열을 리턴합니다.
  if(arr.length < n) return result;

  for(let i = n;i <arr.length ;i++){
    // index가 n일때 부터 배열의 끝까지 새로운 배열에 추가합니다.
    result = [...result,arr[i]];
  }
  
  return result;
};
```

<br>

4.last
===

last는 배열의 마지막 n개의 element를 담은 새로운 배열을 리턴합니다.    
마지막에서 n개의 element를 리턴해야 되므로 배열의 끝에서부터 n개의의 요소만 추가하면 됩니다.


```javascript
_.last = function (arr, n) {
  let result = [] ;

  // n이 undefined이거나 음수인 경우, 배열의 마지막 요소만을 담은 배열을 리턴합니다.
  if(typeof(n) == "undefined" || n < 0) return [arr[arr.length-1]];

  // n이 배열의 길이를 벗어날 경우, 전체 배열을 shallow copy한 새로운 배열을 리턴합니다.
  if(arr.length < n) return arr;

  // n번 반복
  for(let i = 0;i < n;i++){
    // idx는 배열의 끝 (arr.length-1)에서 시작해서 1씩 감소합니다.
    const idx = arr.length-1-i
    // 뒤에서부터 idx가 시작하므로 element를 새로운 배열의 앞쪽에 추가합니다.
    result = [arr[idx],...result];
  }
  
  return result;
  // TODO: 여기에 코드를 작성합니다.
};
```

<br>

5.each
===

each는 collection의 각 데이터에 반복적인 작업을 수행합니다.   
반복적인 작업은 callback함수를 받습니다.    

collection의 경우 배열일수도 있고 객체일수도 있기때문에 이를 나누는 작업이 필요합니다.   
배열은 객체로 취급되지만 Object.key를 사용해서 key값으로 index를 가져올경우 문자열로 리턴되므로 배열의 경우 따로 처리하는게 좋다고 판단했습니다.

```javascript
_.each = function (collection, iteratee) {
  // collection이 배열인지 객체인지 판단합니다.
  if(Array.isArray(collection)){
    for(let i=0;i<collection.length;i++){
      iteratee(collection[i],i,collection)
    }
  }
  else{
    for(let i = 0; i<Object.keys(collection).length;i++){
      iteratee(Object.values(collection)[i],Object.keys(collection)[i],collection)
    }
  }
};
```

<br>

6.indexOf
===

indexOf는 target으로 전달되는 값이 arr의 요소인 경우, 배열에서의 위치(index)를 리턴합니다.   
전달된 값이 arr에 없을경우 -1을 리턴합니다.   
만약 중복된 값이 존재할 경우, 가장 낮은 index를 리턴합니다.    

배열의 앞에서 부터 순차적으로 값을 비교해서 처음 나온 값을 리턴하면 됩니다.

```javascript
_.indexOf = function (arr, target) {
  let result = -1; // -1로 초기화해서 값이 없을경우 -1로 리턴

  // 구현해둔 _.each 함수를 사용해서 순회
  _.each(arr, function (item, index) {
    if (item === target && result === -1) {
      // 처음 target값을 찾을때 index를 저장합니다.
      result = index; 
    }
  });

  return result;
};
```

<br>

7.filter
===

filter는 test 함수를 통과하는 모든 요소를 담은 새로운 배열을 리턴합니다.
test(element)의 결과가 true일 경우, 통과입니다.
test 함수는 각 요소에 반복 적용됩니다.

앞에서 부터 순차적으로 test함수의 결과가 true일때만 새로운 배열에 넣어서 리턴하면됩니다.

```javascript
_.filter = function (arr, test) {
  let result = [];

  _.each(arr,function(item){
    if(test(item)){
      // test함수 결과가 true일때만 새로운 배열에 추가합니다
      result.push(item);
    }
  });
  
  return result;
};
```

<br>

8.reject
===

reject는 _.filter와 정반대로 test 함수를 통과하지 않는 모든 요소를 담은 새로운 배열을 리턴합니다.   

filter함수일때와 동일한 구조를 가지지만 if문의 조건만 false로 바꿔주면 됩니다.


```javascript
_.reject = function (arr, test) {
  let result = [];

  _.each(arr,function(item){
    if(!test(item)){
      // test함수 결과가 false일때만 새로운 배열에 추가합니다
      result.push(item);
    }
  });
  
  return result;
};
```

<br>

9.uniq
===

uniq는 주어진 배열의 요소가 중복되지 않도록 새로운 배열을 리턴합니다.
중복된 값은 타입, 값 모두 같을경우 중복되었다고 판단합니다.

indexOf 함수를 이용하여 새로운배열에 있는지 판별하여 없을경우에만 새로운 배열에 추가하면됩니다.

```javascript
_.uniq = function (arr) {
  let result = [];

  _.each(arr,function(item){
    // 만들어둔 _.indexOf함수를 사용하여 새로운 배열에 있는지 판단합니다.
    if(_.indexOf(result,item) === -1){
      // 새로운 배열에 없을경우 element 추가합니다.
      result.push(item);
    }
  });

  return result;
};
```

<br>

10.map
===

map은 iteratee(반복되는 작업)를 배열의 각 요소에 적용한 결과를 담은 새로운 배열을 리턴합니다.   

앞에서 부터 순차적으로 iteratee함수의 결과값을 새로운 배열에 추가하여 리턴하면 됩니다.

```javascript
_.map = function (arr, iteratee) {
  let result = [];

  _.each(arr,function(item){
    // 새로운 배열에 iteratee함수를 적용하여 추가합니다.
    result.push(iteratee(item));
  });

  return result;
};
```

<br>

11.plunk
===

pluck은
1. 객체 또는 배열을 요소로 갖는 배열과 각 요소에서 찾고자 하는 key 또는 index를 입력받아
2. 각 요소의 해당 값 또는 요소만을 추출하여 새로운 배열에 저장하고,
3. 최종적으로 새로운 배열을 리턴합니다.

최종적으로 리턴되는 새로운 배열의 길이는 입력으로 전달되는 배열의 길이와 같아야 합니다.   
따라서 찾고자 하는 key 또는 index를 가지고 있지 않은 요소의 경우, 추출 결과는 undefined 입니다.

구현해둔 map함수를 사용하여 키값을 검색한 결과만 추가한 배열을 리턴하면 된다.

```javascript
_.pluck = function (arr, keyOrIdx) { 
  // 만들어둔 map함수를 사용해서 구현
  return _.map(arr,function(item){
    // key or index값의 결과만 리턴한다.
    return item[keyOrIdx];
  });
};
```

<br>

12.reduce
===

reduce는
1. 배열을 순회하며 각 요소에 iteratee 함수를 적용하고,
2. 그 결과값을 계속해서 누적(accumulate)합니다.
3. 최종적으로 누적된 결과값을 리턴합니다.

reduce는 입력으로 배열과 각 요소에 반복할 작업(iteratee)을 전달받습니다.   
iteratee는 차례대로 데이터, 접근자, collection을 다룰 수 있어야 합니다.   
reduce의 경우 누적값을 관리해야 하므로 iteratee는 누적값에 대한 인자가 있어야 합니다.   
누적값의 경우 reduce의 세번째인자로 초기 값을 전달 받을 수 있고, 생략할 경우 배열의 첫번째 요소로 초기화 합니다.   

세번째 요소가 없을경우 undefined가 나오기 때문에 처음에만 해당값을 판별하여 누적값의 초기화를 결정합니다.

```javascript
_.reduce = function (arr, iteratee, initVal) {
  // 누적값은 세번째 인자로 초기화, 생략되었을경우 배열의 첫번째 요소로 초기화 합니다.
  let acc;
  _.each(arr,function(item,idx,arr){
    // 첫번째 index일때 초기화를 어떻게 할지 결정합니다.
    if(idx === 0){
      // 세번째 인자가 생략될경우 누적값을 배열의 첫번째 요소로 할당만 합니다.
      // 초기값이 주어질경우 iteratee연산을 수행합니다.
      if(typeof(initVal) === "undefined"){
        acc = item;
      }
      else{
        acc = iteratee(initVal,item,idx,arr);
      }
    }
    else{
      // iteratee함수를 적용한 결과값을 acc에 누적
      acc =iteratee(acc,item,idx,arr);
    }
    // console.log(acc);
  });
  return acc;
};
```

<br>

13.once
===

once는 callback 함수를 한 번만 호출하는 '함수'를 리턴합니다.
once가 리턴하는 함수를 여러 번 호출해도 callback 함수는 한 번 이상 호출되지 않습니다.

once는 함수를 한번만 호출해야 되기 때문에 호출한적이 있는지 확인하기 위한 변수를 만들고 Closure를 이용해서 변수의 값을 저장해두는 function을 리턴합니다.

```javascript
_.once = function (func) {
  // 1번만 호출하기 위해서 count변수를 사용합니다.
  let count = 0;

  // 결과값이 변하면 안되기 때문에 result변수에 결과를 저장해둡니다.
  let result;

  // 스프레드 연산자를 통해서 func함수의 매개변수를 전부 넘겨준다.
  return function(...ele){
    if(count === 0) {
      // 한번도 실행한적 없을경우 함수 실행합니다.
      count = 1;
      result = func(...ele);
    }
    // 실행한적 있을경우 기존의 저장된 값을 리턴합니다.
    return result;
  };
};
```
<br>

14.